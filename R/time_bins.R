#' Generate time bins
#'
#' A function to generate time bins for a given study interval. This function
#' is flexible in that either stage-level or higher stratigraphic-level
#' (period) time bins can be called.
#' In addition, near equal-length time bins can be generated by grouping stages
#' together. In this implementation, intervals are grouped together in a way
#' that creates near equal-length time bins based on the user's specified bin
#' size (e.g., if a user specifies 10 Myr as their target bin size, the
#' function will generate groups of bins that have a mean bin length close to
#' 10 Myr).
#' However, users may also want to consider grouping stages based on other
#' reasoning e.g. availability of outcrop (see Dean et al. (2020);
#' \doi{https://doi.org/10.1111/pala.12492}).
#'
#' @param interval \code{character or numeric}. Interval name of age available
#' in \code{\link[palaeoverse]{GTS2020}} or \code{\link[palaeoverse]{GTS2012}}.
#' If a single interval name is provided, this interval is returned.
#' If two interval names are provided, these intervals and those existing
#' between are returned. If a single numeric age is provided, the interval that
#' covers this age is returned.
#' If two interval ages are provided, the intervals occurring in the range of
#' these ages are returned. If higher-level units than stages are required,
#' these can only be specified using a  \code{character} input as the function
#' defaults to using stratigraphic stages for \code{numeric} inputs. The
#' default input for this argument is `c("Fortunian", "Meghalayan"`).
#' @param rank \code{character}. Which stratigraphic rank is desired? Choose
#' from: "stage", "epoch", "period", "era", and "eon".
#' This argument defaults to NULL, in which case the rank will be identified
#' from the interval names.
#' @param size \code{numeric}. If equal-length time bins are desired, specify
#' the length in millions of years (Myr) of the time bins desired.
#' @param assign \code{numeric}. A numeric vector of age estimates (e.g.,
#' midpoint age in specified age range) to use to assign to bins of a given
#' size. If assign is specified, a numeric vector is returned of the midpoint
#' age of the specified bins. Note this is the simplified approach of
#' assignment in `palaeoverse`. See \code{\link[palaeoverse]{time_binning()}}
#' for a wider range of binning approaches.
#' @param scale \code{character}. Specify the desired geological timescale to
#' be used "GTS2020" or "GTS2012". "GTS2020" is the default.
#' @param plot \code{logical}. Should a plot of time bins be generated?
#' @importFrom graphics polygon title
#' @importFrom stats sd
#'
#' @return A \code{dataframe} of time bins for the specified intervals or a
#' list with a \code{dataframe} of time bins and \code{numeric} vector of
#' binned age estimates (midpoint of specified bins) if assign is specified.
#'
#' @details This function uses the Geological Timescale 2020 and the Geological
#' Timescale 2012 (depending on user specification).
#' Additional information on each timescale and source can be accessed via the
#' calls:
#' - \code{?palaeoverse::GTS2020()}
#' - \code{?palaeoverse::GTS2012()}
#'
#' Available intervals names are also accessible via
#' \code{GTS2020$interval_name} or \code{GTS2012$interval_name}. Data from the
#' Geological Timescale 2020 and 2012 were compiled by Lewis A. Jones
#' (2022-07-02).
#' @section Developer(s):
#' Lewis A. Jones
#' @section Reviewer(s):
#' Kilian Eichenseer
#' @export
#' @examples
#' #Using interval midpoint age
#' time_bins(interval = 10, plot = TRUE)
#'
#' #Using interval age range
#' time_bins(interval = c(50, 100), plot = TRUE)
#'
#' #Using a single interval name
#' time_bins(interval = c("Maastrichtian"), plot = TRUE)
#'
#' #Using a range of intervals defined by two named intervals and equal
#' duration bins
#' time_bins(interval = c("Fortunian", "Meghalayan"), size = 10, plot = TRUE)
#'
#' #Assign bins based on given age estimates
#' time_bins(interval = c("Fortunian", "Meghalayan"), assign = c(232, 167, 33))
time_bins <-
  function(interval = c("Fortunian", "Meghalayan"),
           rank = "stage",
           size = NULL,
           assign = NULL,
           scale = "GTS2020",
           plot = FALSE) {
    # Error handling
    if (!is.character(interval) & !is.numeric(interval)) {
      stop("`interval` must be of class 'character' or 'numeric'")
    }

    if (is.numeric(size) == FALSE & is.null(size) == FALSE) {
      stop("`size` should be a numeric or NULL")
    }

    if (is.logical(plot) == FALSE) {
      stop("`plot` should be logical (TRUE/FALSE)")
    }

    if (is.numeric(assign) == TRUE & any(assign < 0) == TRUE) {
      stop(
        "Age estimates for `assign` should be non-negative values.
  You can transform your data using abs()."
      )
    }

    if (scale != "GTS2012" & scale != "GTS2020") {
      stop("`scale` must be either GTS2012 or GTS2020")
    }

    if (length(interval) > 2) {
      stop("`interval` must be a character or numeric vector of length 1 or 2")
    }

    if ((rank %in% c("stage", "epoch", "period", "era", "eon")) == FALSE) {
      stop("`rank` must be either: stage, epoch, period, era, or eon")
    }

    if (length(rank) > 1) {
      stop("`rank` must be of length 1")
    }

    # Grab data
    # Which geological timescale to use?

    if (scale == "GTS2020") {
      df <- palaeoverse::GTS2020
    }
    if (scale == "GTS2012") {
      df <- palaeoverse::GTS2012
    }

    #drop columns
    drop <- c("index", "stage_number", "series_number", "system_number")
    df <- df[,-which(colnames(df) %in% drop)]

    # rank ages
    rank_ages <- df[which(df$rank == rank),]

    #character string entered
    if (is.character(interval) & length(interval) == 1) {
        w <- which(df$interval_name %in% interval)
        if (length(w) != length(interval)) {
          stop(
            paste0(
              "Check spelling of specified intervals.
  Available intervals are accessible via GTS2020 and GTS2012."
            )
          )
        }
        rank_ages <-
          rank_ages[which(rank_ages$max_ma > df$min_ma[w] &
                            rank_ages$min_ma < df$max_ma[w]), ]
        df <- rank_ages
      }
      if (is.character(interval) & length(interval) == 2) {
        w <- which(df$interval_name %in% interval)
        if (length(w) != length(interval)) {
          stop(
            paste0(
              "Check spelling of specified intervals.
  Available intervals are accessible via GTS2020 and GTS2012."
            )
          )
        }
        rank_ages <-
          rank_ages[which(rank_ages$max_ma > min(df$min_ma[w]) &
                            rank_ages$min_ma < max(df$max_ma[w])), ]
        df <- subset(df, max_ma <= max(rank_ages$max_ma))
        df <- subset(df, min_ma >= min(rank_ages$min_ma))
      }

    #subset to rank
    df <- df[which(df$rank == rank),]

    #numeric ages entered
    if (is.numeric(interval) & length(interval) == 1) {
        if (interval > max(df$max_ma) | interval < min(df$min_ma)) {
          stop("Value does not appear in the range of available intervals:
          0 to 541")
        }
        int_index <-
          which(interval <= df$max_ma & interval >= df$min_ma)
        df <- df[int_index,]
      }

      if (is.numeric(interval) & length(interval) == 2) {
        max_int <- max(interval)
        min_int <- min(interval)

        if (max_int > max(df$max_ma) | min_int < min(df$min_ma)) {
          stop("Values do not appear in the range of available intervals:
          0 to 541")
        }

        int_index <-
          which(min_int <= df$max_ma & max_int >= df$min_ma)
        df <- df[int_index,]
      }

    bin <- nrow(df):1
    df <- cbind.data.frame(bin, df)

    #are equal length time bins required?
    if (is.numeric(size) == TRUE) {
      # duration of interval we want to bin
      dur <- max(df$max_ma) - min(df$min_ma)
      # number of bins, based on bin size
      nbin <- max(c(round(dur / size), 1))
      # sort mid ages into bins
      binlist <-
        cut(
          df$mid_ma,
          breaks = seq(min(df$min_ma), max(df$max_ma), length.out = nbin + 1),
          include.lowest = T
        )
      levels(binlist) <- 1:nbin # levels from 1:nbin for convenience
      # convert to interval names
      binlist <-
        sapply(1:nbin, function(x)
          df$interval_name[which(binlist == x)])
      # make list if its only one bin
      if (!("list" %in% class(binlist)))
        binlist <- list(binlist)
      # remove empty bins
      binlist <-
        binlist[which(sapply(binlist, function(x)
          ! (identical(x, character(
            0
          )))))]

      #generate bin information
      bin <- length(binlist):1
      max_ma <- sapply(binlist, function(x)
        max(df$max_ma[which(df$interval_name %in% x)]))
      min_ma <- sapply(binlist, function(x)
        min(df$min_ma[which(df$interval_name %in% x)]))
      mid_ma <- (max_ma + min_ma) / 2
      duration_myr <- max_ma - min_ma
      intervals <- sapply(binlist, function(x)
        toString(x, sep = ", "))

      #generate dataframe
      grouping_rank <- rank
      df <-
        cbind.data.frame(bin,
                         max_ma,
                         mid_ma,
                         min_ma,
                         duration_myr,
                         grouping_rank,
                         intervals)

      #message user
      message(
        paste0(
          "Target equal length time bins was set to ",
          size,
          " Myr. \nGenerated time bins have a mean length of ",
          round(mean(df$duration_myr), digits = 2),
          " Myr and a standard deviation of ",
          round(sd(df$duration_myr), digits = 2),
          " Myr."
        )
      )
    }

    if (plot == TRUE) {
      if (is.numeric(size) == TRUE) {
        df$colour <- c("#4292c6")
      }
      plot(
        1,
        type = "n",
        xlim = c(max(df$max_ma), min(df$min_ma)),
        ylim = c(0, max(df$duration_myr)),
        xlab = "Time (Ma)",
        ylab = "Duration (Myr)"
      )
      for (i in 1:nrow(df)) {
        polygon(
          x = c(df$min_ma[i], df$max_ma[i], df$max_ma[i], df$min_ma[i]),
          y = c(0, 0, df$duration_myr[i], df$duration_myr[i]),
          col = df$colour[i]
        )
      }
      if (is.numeric(size) == TRUE) {
        title(paste0(
          "Mean bin length = ",
          round(mean(df$duration_myr), digits = 2),
          " (standard deviation = ",
          round(sd(df$duration_myr), digits = 2),
          ")"
        ))
        df <- df[,-which(colnames(df) == "colour")]
      }

      if (is.numeric(size) == FALSE) {
        df$bin <- nrow(df):1
        df <-
          df[, c("bin",
                 "interval_name",
                 "max_ma",
                 "mid_ma",
                 "min_ma",
                 "duration_myr",
                 "rank")]
      }
      df <- df[order(df$bin, decreasing = FALSE),]

    }

    if (!is.null(assign)) {
      if (is.numeric(assign)) {
        if (any(assign > max(df$max_ma) | assign < min(df$min_ma))) {
          stop("One or more ages is outside the specified time interval range")
        }
        tmp <- assign
        for (i in 1:nrow(df)) {
          assign[which(tmp <= df$max_ma[i] &
                         tmp >= df$min_ma[i])] <- df$interval_name[i]
        }
        assign <- list(df, assign)
        names(assign) <- c("Bins", "Assignation")
        return(assign)
      } else{
        stop("`assign` should be a numeric")
      }
    }
    return(df)
  }
